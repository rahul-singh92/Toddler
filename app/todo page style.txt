"use client";
import { useState, useEffect } from "react";
import ProtectedRoute from "../components/ProtectedRoute";
import LeftSidebar from "../components/LeftSidebar";
import TodoModal from "../components/TodoModal";
import TodoSidebar from "../components/todo/TodoSidebar";
import TodoDetailsModal from "../components/todo/TodoDetailsModal";
import { IconChevronLeft, IconChevronRight, IconRepeat } from "@tabler/icons-react";
import { motion, AnimatePresence } from "framer-motion";
import { Todo } from "../types/todo";
import { collection, query, onSnapshot, orderBy } from "firebase/firestore";
import { useAuthState } from "react-firebase-hooks/auth";
import { auth, db } from "../lib/firebase";

function getWeekNumber(date: Date) {
  const firstDayofYear = new Date(date.getFullYear(), 0, 1);
  const pastDays = (date.getTime() - firstDayofYear.getTime()) / 86400000;
  return Math.ceil((pastDays + firstDayofYear.getDay() + 1) / 7);
}

// Helper function to get 5 days centered around today
function getCurrentWeekDates(): Date[] {
  const today = new Date();
  const weekDates = [];
  
  // Show: yesterday, today, tomorrow, day after tomorrow, day after that
  for (let i = -1; i <= 3; i++) {
    const date = new Date(today.getTime() + i * 24 * 60 * 60 * 1000);
    weekDates.push(date);
  }
  
  return weekDates;
}

// Helper function to generate recurring dates for a todo
function generateRecurringDates(todo: Todo, viewStartDate: Date, viewEndDate: Date): Date[] {
  if (!todo.recurrence || todo.recurrence.type === 'none' || !todo.startTime) {
    return []; // Return empty array for non-recurring todos
  }

  const dates: Date[] = [];
  const startDate = new Date(todo.startTime);
  const interval = todo.recurrence.interval || 1;
  
  // Set end date - either recurrence end date or 6 months from start (to prevent infinite generation)
  let endDate = viewEndDate;
  if (todo.recurrence.endDate) {
    const recurrenceEndDate = typeof todo.recurrence.endDate === 'string' 
      ? new Date(todo.recurrence.endDate) 
      : todo.recurrence.endDate instanceof Date 
        ? todo.recurrence.endDate
        : new Date(todo.recurrence.endDate);
    endDate = new Date(Math.min(endDate.getTime(), recurrenceEndDate.getTime()));
  }

  let currentDate = new Date(startDate);
  
  while (currentDate <= endDate && dates.length < 100) { // Limit to prevent infinite loops
    // Check if current date is within our view range
    if (currentDate >= viewStartDate && currentDate <= viewEndDate) {
      dates.push(new Date(currentDate));
    }
    
    // Calculate next occurrence
    switch (todo.recurrence.type) {
      case 'daily':
        currentDate.setDate(currentDate.getDate() + interval);
        break;
      case 'weekly':
        currentDate.setDate(currentDate.getDate() + (7 * interval));
        break;
      case 'monthly':
        currentDate.setMonth(currentDate.getMonth() + interval);
        break;
      case 'yearly':
        currentDate.setFullYear(currentDate.getFullYear() + interval);
        break;
      default:
        break;
    }
    
    // Safety check to prevent infinite loops
    if (currentDate.getTime() === startDate.getTime()) {
      break;
    }
  }
  
  return dates;
}

// Helper function to check if two todos overlap in time
function todosOverlap(todo1: Todo, todo2: Todo): boolean {
  if (!todo1.startTime || !todo2.startTime) return false;
  
  const start1 = todo1.startTime.getTime();
  const end1 = todo1.endTime ? todo1.endTime.getTime() : start1 + (60 * 60 * 1000); // Default 1 hour
  const start2 = todo2.startTime.getTime();
  const end2 = todo2.endTime ? todo2.endTime.getTime() : start2 + (60 * 60 * 1000); // Default 1 hour
  
  return start1 < end2 && start2 < end1;
}

// Helper function to group overlapping todos - FIXED TypeScript warnings
function groupOverlappingTodos(todos: Todo[]): Todo[][] {
  const groups: Todo[][] = [];
  const processed = new Set<string>();
  
  todos.forEach(todo => {
    // FIXED: Added null check for todo.id
    if (!todo.id || processed.has(todo.id)) return;
    
    const overlappingGroup = [todo];
    processed.add(todo.id);
    
    todos.forEach(otherTodo => {
      // FIXED: Added null checks for otherTodo.id
      if (otherTodo.id && otherTodo.id !== todo.id && !processed.has(otherTodo.id)) {
        // Check if this todo overlaps with any todo in the current group
        const overlapsWithGroup = overlappingGroup.some(groupTodo => todosOverlap(groupTodo, otherTodo));
        if (overlapsWithGroup) {
          overlappingGroup.push(otherTodo);
          processed.add(otherTodo.id);
        }
      }
    });
    
    groups.push(overlappingGroup);
  });
  
  return groups;
}

// Helper functions for checking dates and weeks
function isThisWeek(date: Date): boolean {
  const today = new Date();
  const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate());
  
  const todayDay = todayStart.getDay();
  const mondayOffset = todayDay === 0 ? -6 : 1 - todayDay;
  const mondayStart = new Date(todayStart.getTime() + mondayOffset * 24 * 60 * 60 * 1000);
  
  const sundayEnd = new Date(mondayStart.getTime() + 6 * 24 * 60 * 60 * 1000 + 23 * 60 * 60 * 1000 + 59 * 60 * 1000 + 59 * 1000);
  
  return date >= mondayStart && date <= sundayEnd;
}

function isSameDay(date1: Date, date2: Date): boolean {
  return date1.getDate() === date2.getDate() &&
         date1.getMonth() === date2.getMonth() &&
         date1.getFullYear() === date2.getFullYear();
}

function isThisMonth(date: Date): boolean {
  const today = new Date();
  return date.getMonth() === today.getMonth() && date.getFullYear() === today.getFullYear();
}

function HeaderBar() {
  const today = new Date();
  const [currentDate, setCurrentDate] = useState(today);
  const monthYear = currentDate.toLocaleString("default", { month: "long", year: "numeric" });
  const week = getWeekNumber(currentDate);

  const navigateWeek = (direction: 'prev' | 'next') => {
    const newDate = new Date(currentDate);
    newDate.setDate(currentDate.getDate() + (direction === 'next' ? 5 : -5));
    setCurrentDate(newDate);
  };

  const goToToday = () => {
    setCurrentDate(new Date());
  };

  return (
    <div className="sticky top-0 z-30 bg-white px-8 py-5 flex items-center justify-between border-b border-gray-200">
      <div className="flex items-center space-x-6">
        <h1 className="text-2xl font-bold text-gray-900">{monthYear}</h1>
        <div className="flex items-center space-x-4">
          <span className="text-4xl leading-none text-gray-300">/</span>
          <div className="flex items-center gap-2">
            <span className="font-semibold text-lg text-gray-700">W{week}</span>
          </div>
        </div>
        <div className="flex items-center space-x-2">
          <button 
            onClick={() => navigateWeek('prev')}
            className="p-2 rounded hover:bg-gray-100 transition-colors"
          >
            <IconChevronLeft size={20} stroke={2} className="text-gray-600" />
          </button>
          <button 
            onClick={() => navigateWeek('next')}
            className="p-2 rounded hover:bg-gray-100 transition-colors"
          >
            <IconChevronRight size={20} stroke={2} className="text-gray-600" />
          </button>
        </div>
      </div>

      <div className="flex space-x-3">
        <button 
          onClick={goToToday}
          className="px-4 py-2 rounded-md bg-gray-100 text-gray-700 text-sm font-medium hover:bg-gray-200 transition-colors"
        >
          Today
        </button>
        <button className="px-4 py-2 rounded-md bg-gray-900 text-white text-sm font-medium hover:bg-gray-800 transition-colors">
          Share
        </button>
      </div>
    </div>
  );
}

interface TodoGroup {
  key: string;
  title: string;
  todos: Todo[];
  isDateBased?: boolean;
}

// Individual Todo Card Component - PERFECT STACKING FIX
function TodoCard({ 
  todo, 
  onClick, 
  instanceDate, 
  stackIndex = 0, 
  isStacked = false, 
  isExpanded = false,
  totalInStack = 1
}: { 
  todo: Todo; 
  onClick: () => void; 
  instanceDate?: Date;
  stackIndex?: number;
  isStacked?: boolean;
  isExpanded?: boolean;
  totalInStack?: number;
}) {
  const formatTime = (date?: Date) => {
    if (!date) return '';
    return date.toLocaleTimeString('en-US', { 
      hour: 'numeric', 
      minute: '2-digit', 
      hour12: true 
    });
  };

  // Function to determine if the background color is light or dark
  const isLightColor = (hex: string) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    
    // Calculate luminance
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return luminance > 0.5;
  };

  // Use instanceDate for display if provided (for recurring todos)
  const displayTime = instanceDate || todo.startTime;

  // Determine text color based on background
  const textColor = isLightColor(todo.color) ? '#000000' : '#FFFFFF';
  const timeColor = isLightColor(todo.color) ? 'rgba(0,0,0,0.7)' : 'rgba(255,255,255,0.8)';

  // Calculate duration and positioning
  const calculateTimeSpan = () => {
    if (!todo.startTime || !todo.endTime) {
      return { height: 64 }; // Regular height for todos without end time
    }

    const startHour = todo.startTime.getHours();
    const endHour = todo.endTime.getHours();
    const startMinutes = todo.startTime.getMinutes();
    const endMinutes = todo.endTime.getMinutes();

    // Convert to decimal hours
    const startDecimal = startHour + startMinutes / 60;
    const endDecimal = endHour + endMinutes / 60;
    
    // Calculate duration in hours
    const durationHours = endDecimal - startDecimal;
    
    // Each hour slot is 80px total
    const pixelsPerHour = 80;
    const totalHeight = durationHours * pixelsPerHour;
    
    return {
      height: Math.max(totalHeight, 64) // Minimum height of one slot
    };
  };

  const timeSpan = calculateTimeSpan();

  // FIXED: Perfect stacking - cards stack exactly on top of each other
  const getStackStyles = () => {
    if (!isStacked) return { transform: 'none', zIndex: 10 };
    
    if (isExpanded) {
      // FIXED: Vertical fan-out to avoid mouse hover issues
      const verticalSpread = stackIndex * 70; // Spread vertically
      const horizontalOffset = (stackIndex - (totalInStack - 1) / 2) * 20; // Small horizontal offset
      
      return {
        transform: `translateY(${verticalSpread}px) translateX(${horizontalOffset}px)`,
        zIndex: 60 + stackIndex,
      };
    }
    
    // FIXED: Perfect stack - minimal offset, cards stay in time slot
    const edgeOffset = Math.min(stackIndex * 2, 6); // Max 6px offset
    
    return {
      transform: `translateX(${edgeOffset}px)`,
      zIndex: 20 + stackIndex,
    };
  };

  const stackStyles = getStackStyles();

  return (
    <motion.div 
      layout
      initial={false}
      animate={stackStyles}
      transition={{ 
        type: "spring", 
        stiffness: 300, 
        damping: 25,
        duration: 0.2
      }}
      className="absolute w-full p-3 rounded-lg shadow-md hover:shadow-xl transition-all duration-200 cursor-pointer overflow-hidden"
      style={{ 
        backgroundColor: todo.color,
        height: `${timeSpan.height}px`,
        zIndex: stackStyles.zIndex,
        // FIXED: Remove marginTop that was causing position issues
        top: stackIndex === 0 ? '0px' : '0px', // All cards at same position
      }}
      onClick={onClick}
    >
      {/* Stack indicator - show count on top card */}
      {isStacked && stackIndex === totalInStack - 1 && totalInStack > 1 && !isExpanded && (
        <div className="absolute -top-1 -right-1 w-5 h-5 rounded-full bg-gray-800 text-white text-xs flex items-center justify-center font-bold shadow-lg z-10">
          {totalInStack}
        </div>
      )}

      {/* Recurring indicator */}
      {todo.recurrence?.type !== 'none' && (
        <div className="absolute top-2 right-2">
          <IconRepeat size={10} style={{ color: timeColor }} />
        </div>
      )}

      {/* Main content */}
      <div className="h-full flex flex-col">
        {/* Title */}
        <h4 
          className="font-semibold text-sm mb-1 pr-4" 
          style={{ 
            color: textColor,
            lineHeight: '1.2'
          }}
        >
          {todo.title}
        </h4>
        
        {/* Time range */}
        <div className="text-xs font-medium mb-2" style={{ color: timeColor }}>
          {displayTime && formatTime(displayTime)}
          {todo.endTime && todo.startTime && ` - ${formatTime(todo.endTime)}`}
        </div>

        {/* Description for longer events */}
        {todo.description && timeSpan.height > 100 && 
         (stackIndex === totalInStack - 1 || isExpanded) && (
          <div 
            className="text-xs opacity-75 flex-1 overflow-hidden"
            style={{ color: timeColor }}
          >
            {todo.description}
          </div>
        )}

        {/* Completion indicator - small dot */}
        {todo.completed && (
          <div 
            className="absolute bottom-2 right-2 w-2 h-2 rounded-full"
            style={{ 
              backgroundColor: isLightColor(todo.color) ? 'rgba(0,0,0,0.6)' : 'rgba(255,255,255,0.8)'
            }}
          />
        )}
      </div>
    </motion.div>
  );
}

// FIXED: Better hover behavior and stable interaction
function StackedTodoCards({ todos, onTodoClick }: { todos: Todo[]; onTodoClick: (todo: Todo) => void }) {
  const [isHovered, setIsHovered] = useState(false);
  const [hoverTimeout, setHoverTimeout] = useState<NodeJS.Timeout | null>(null);
  
  if (todos.length === 1) {
    return (
      <div className="relative">
        <TodoCard 
          todo={todos[0]} 
          onClick={() => onTodoClick(todos[0])}
          instanceDate={todos[0].startTime}
        />
      </div>
    );
  }

  // Sort todos by priority and creation time for consistent stacking order
  const sortedTodos = [...todos].sort((a, b) => {
    const priorityOrder = { high: 3, medium: 2, low: 1 };
    const aPriority = priorityOrder[a.priority as keyof typeof priorityOrder] || 1;
    const bPriority = priorityOrder[b.priority as keyof typeof priorityOrder] || 1;
    
    if (aPriority !== bPriority) return aPriority - bPriority; // Lower priority first (bottom of stack)
    return a.createdAt.getTime() - b.createdAt.getTime(); // Older first
  });

  // FIXED: Better hover handling with delays
  const handleMouseEnter = () => {
    if (hoverTimeout) clearTimeout(hoverTimeout);
    setIsHovered(true);
  };

  const handleMouseLeave = () => {
    // Add small delay before collapsing to prevent flickering
    const timeout = setTimeout(() => {
      setIsHovered(false);
    }, 200);
    setHoverTimeout(timeout);
  };

  // Calculate the height needed for expanded state
  const maxHeight = Math.max(...sortedTodos.map(todo => {
    if (!todo.startTime || !todo.endTime) return 64;
    const duration = (todo.endTime.getTime() - todo.startTime.getTime()) / (1000 * 60 * 60);
    return Math.max(duration * 80, 64);
  }));

  const expandedHeight = isHovered ? maxHeight + (sortedTodos.length - 1) * 70 : maxHeight;

  return (
    <div 
      className="relative"
      style={{ 
        height: `${expandedHeight}px`,
        transition: 'height 0.3s ease'
      }}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      {sortedTodos.map((todo, index) => (
        <TodoCard
          key={todo.id}
          todo={todo}
          onClick={() => onTodoClick(todo)}
          instanceDate={todo.startTime}
          stackIndex={index}
          isStacked={true}
          isExpanded={isHovered}
          totalInStack={sortedTodos.length}
        />
      ))}
    </div>
  );
}

/* --- Todo page --- */
export default function TodoPage() {
  const [user] = useAuthState(auth);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [selectedTodo, setSelectedTodo] = useState<Todo | null>(null);
  const [isDetailsModalOpen, setIsDetailsModalOpen] = useState(false);
  const [todos, setTodos] = useState<Todo[]>([]);
  const [loading, setLoading] = useState(true);
  const [currentWeekDates, setCurrentWeekDates] = useState(getCurrentWeekDates());

  // Update week dates when component mounts
  useEffect(() => {
    setCurrentWeekDates(getCurrentWeekDates());
  }, []);

  // Fetch todos from Firestore in real-time
  useEffect(() => {
    if (!user) {
      setTodos([]);
      setLoading(false);
      return;
    }

    const todosRef = collection(db, 'users', user.uid, 'todos');
    const q = query(todosRef, orderBy('createdAt', 'desc'));

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const todosList: Todo[] = [];
      snapshot.forEach((doc) => {
        const data = doc.data();
        todosList.push({
          id: doc.id,
          title: data.title,
          description: data.description,
          category: data.category,
          links: data.links || [],
          startTime: data.startTime?.toDate(),
          endTime: data.endTime?.toDate(),
          completed: data.completed,
          priority: data.priority,
          color: data.color,
          style: data.style,
          createdAt: data.createdAt?.toDate() || new Date(),
          updatedAt: data.updatedAt?.toDate() || new Date(),
          sharedWith: data.sharedWith || [],
          recurrence: {
            type: data.recurrence?.type || 'none',
            interval: data.recurrence?.interval,
            endDate: data.recurrence?.endDate?.toDate?.() || data.recurrence?.endDate
          },
          ownerId: data.ownerId,
        });
      });
      setTodos(todosList);
      setLoading(false);
    }, (error) => {
      console.error("Error fetching todos:", error);
      setLoading(false);
    });

    return () => unsubscribe();
  }, [user]);

  // Handle new todo added from modal
  const handleTodoAdded = (newTodo: Todo) => {
    console.log("New todo added:", newTodo);
  };

  // Handle todo click
  const handleTodoClick = (todo: Todo) => {
    setSelectedTodo(todo);
    setIsDetailsModalOpen(true);
  };

  // Group todos dynamically with recurrence expansion
  const getGroupedTodos = (): TodoGroup[] => {
    if (loading || todos.length === 0) {
      return [];
    }

    const groups: TodoGroup[] = [];
    
    // Expand recurring todos
    const expandedTodos: Todo[] = [];
    const viewStartDate = new Date(Math.min(...currentWeekDates.map(d => d.getTime())));
    const viewEndDate = new Date(Math.max(...currentWeekDates.map(d => d.getTime())));
    
    todos.forEach(todo => {
      if (todo.recurrence?.type !== 'none' && todo.startTime) {
        // Generate recurring instances
        const recurringDates = generateRecurringDates(todo, viewStartDate, viewEndDate);
        recurringDates.forEach(date => {
          expandedTodos.push({
            ...todo,
            id: `${todo.id}-${date.getTime()}`, // Unique ID for each instance
            startTime: new Date(date.getFullYear(), date.getMonth(), date.getDate(), 
                              todo.startTime!.getHours(), todo.startTime!.getMinutes()),
            endTime: todo.endTime ? new Date(date.getFullYear(), date.getMonth(), date.getDate(), 
                                           todo.endTime.getHours(), todo.endTime.getMinutes()) : undefined
          });
        });
      } else {
        // Non-recurring todos or all-day todos
        expandedTodos.push(todo);
      }
    });

    // Date-based groups with expanded todos
    const thisWeekTodos = expandedTodos.filter(todo => {
      if (todo.startTime) return isThisWeek(todo.startTime);
      return isThisWeek(todo.createdAt);
    });

    const thisMonthTodos = expandedTodos.filter(todo => {
      if (todo.startTime) return isThisMonth(todo.startTime);
      return isThisMonth(todo.createdAt);
    });

    if (thisWeekTodos.length > 0) {
      groups.push({
        key: "thisWeek",
        title: "This Week",
        todos: thisWeekTodos,
        isDateBased: true,
      });
    }

    if (thisMonthTodos.length > 0) {
      groups.push({
        key: "thisMonth",
        title: "This Month",
        todos: thisMonthTodos,
        isDateBased: true,
      });
    }

    // Category-based groups with original todos (no expansion for sidebar)
    const categoriesMap = new Map<string, Todo[]>();
    
    todos.forEach(todo => {
      const category = todo.category || 'uncategorized';
      if (!categoriesMap.has(category)) {
        categoriesMap.set(category, []);
      }
      categoriesMap.get(category)!.push(todo);
    });

    categoriesMap.forEach((todosList, category) => {
      groups.push({
        key: category,
        title: category.charAt(0).toUpperCase() + category.slice(1),
        todos: todosList,
        isDateBased: false,
      });
    });

    return groups;
  };

  const groups = getGroupedTodos();

  // Get todos for a specific date - MODIFIED FOR STACKING
  const getTodosForDate = (date: Date): Todo[] => {
    const result: Todo[] = [];
    const viewStartDate = new Date(Math.min(...currentWeekDates.map(d => d.getTime())));
    const viewEndDate = new Date(Math.max(...currentWeekDates.map(d => d.getTime())));
    
    todos.forEach(todo => {
      if (todo.recurrence?.type !== 'none' && todo.startTime) {
        // Check if this recurring todo should appear on this date
        const recurringDates = generateRecurringDates(todo, viewStartDate, viewEndDate);
        const matchingDate = recurringDates.find(recurDate => isSameDay(recurDate, date));
        
        if (matchingDate) {
          // Create instance for this date
          result.push({
            ...todo,
            id: `${todo.id}-${matchingDate.getTime()}`,
            startTime: new Date(matchingDate.getFullYear(), matchingDate.getMonth(), matchingDate.getDate(), 
                              todo.startTime.getHours(), todo.startTime.getMinutes()),
            endTime: todo.endTime ? new Date(matchingDate.getFullYear(), matchingDate.getMonth(), matchingDate.getDate(), 
                                           todo.endTime.getHours(), todo.endTime.getMinutes()) : undefined
          });
        }
      } else {
        // Non-recurring todos
        if (todo.startTime) {
          if (isSameDay(todo.startTime, date)) {
            result.push(todo);
          }
        } else {
          if (isSameDay(todo.createdAt, date)) {
            result.push(todo);
          }
        }
      }
    });
    
    return result;
  };

  return (
    <ProtectedRoute>
      <div className="flex min-h-screen overflow-hidden bg-gray-50">
        {/* LEFT SIDEBAR */}
        <LeftSidebar onToggleSidebar={() => setSidebarCollapsed((s) => !s)} />

        {/* TODO SIDEBAR */}
        <TodoSidebar
          sidebarCollapsed={sidebarCollapsed}
          groups={groups}
          onAddTodo={() => setIsModalOpen(true)}
          loading={loading}
        />

        {/* Main content area */}
        <motion.main 
          initial={false} 
          animate={{ marginLeft: sidebarCollapsed ? "5rem" : "23rem" }} 
          transition={{ duration: 0.3, ease: "easeInOut" }} 
          className="flex-1 overflow-x-hidden bg-white"
        >
          {/* Fixed top header */}
          <HeaderBar />
          
          {/* Calendar Grid */}
          <div className="p-6">
            {/* Date Headers Row */}
            <div className="grid grid-cols-6 gap-4 mb-6">
              {/* Empty space for time labels column */}
              <div></div>
              
              {/* Date headers */}
              {currentWeekDates.map((date, index) => {
                const isToday = isSameDay(date, new Date());
                
                return (
                  <div key={index} className="text-center">
                    <div className={`text-5xl font-bold mb-1 ${
                      isToday 
                        ? 'text-black' 
                        : 'text-gray-400'
                    }`}>
                      {date.getDate().toString().padStart(2, '0')}
                    </div>
                    <div className={`text-sm font-medium lowercase tracking-wide ${
                      isToday 
                        ? 'text-black font-bold' 
                        : 'text-gray-500 font-normal'
                    }`}>
                      {date.toLocaleDateString('en-US', { weekday: 'short' })}
                    </div>
                    {/* Small vertical line under the day name - darker for current day */}
                    <div className="flex justify-center mt-2">
                      <div className={`w-0.5 h-4 ${
                        isToday 
                          ? 'bg-black' 
                          : 'bg-gray-300'
                      }`}></div>
                    </div>
                  </div>
                );
              })}
            </div>

            {/* Time labels column + Date columns - EXPANDED TIME RANGE */}
            <div className="grid grid-cols-6 gap-4">
              {/* Time labels column - Extended from 6 AM to 11 PM */}
              <div className="space-y-4">
                <div className="h-20 flex items-start pt-2">
                  <span className="text-xs text-gray-500 font-medium">all day</span>
                </div>
                {/* Time slots - Extended range */}
                {Array.from({ length: 17 }, (_, i) => {
                  const hour = i + 6; // Start from 6 AM
                  let timeLabel;
                  if (hour === 0) timeLabel = '12 am';
                  else if (hour === 12) timeLabel = '12 pm';
                  else if (hour < 12) timeLabel = `${hour} am`;
                  else timeLabel = `${hour - 12} pm`;
                  
                  return (
                    <div key={hour} className="h-16 flex items-start">
                      <span className="text-xs text-gray-500 font-medium">{timeLabel}</span>
                    </div>
                  );
                })}
              </div>

              {/* Date columns - 5 days centered around today */}
              {currentWeekDates.map((date, index) => {
                const dayTodos = getTodosForDate(date);
                
                return (
                  <div key={index} className="relative">
                    {/* All day events */}
                    <div className="min-h-[80px] space-y-2 mb-4">
                      {dayTodos
                        .filter(todo => !todo.startTime || todo.startTime.getHours() === 0)
                        .map(todo => (
                          <TodoCard 
                            key={todo.id} 
                            todo={todo} 
                            onClick={() => handleTodoClick(todo)}
                          />
                        ))}
                    </div>

                    {/* Time slot events - MODIFIED FOR STACKING */}
                    <div className="relative" style={{ minHeight: '17 * 80px' }}>
                      {/* Group overlapping todos and render stacks */}
                      {(() => {
                        const timedTodos = dayTodos.filter(todo => todo.startTime && todo.startTime.getHours() > 0);
                        const overlappingGroups = groupOverlappingTodos(timedTodos);
                        
                        return overlappingGroups.map((todoGroup, groupIndex) => {
                          const firstTodo = todoGroup[0];
                          const startHour = firstTodo.startTime!.getHours();
                          const startMinutes = firstTodo.startTime!.getMinutes();
                          
                          // Calculate position from 6 AM (our start time)
                          const hoursFromStart = startHour - 6;
                          const minutesFromStart = startMinutes;
                          
                          // Each hour slot is 80px (64px height + 16px gap)
                          const topOffset = (hoursFromStart * 80) + (minutesFromStart / 60 * 80);
                          
                          return (
                            <div
                              key={`group-${groupIndex}`}
                              className="absolute w-full"
                              style={{ 
                                top: `${Math.max(topOffset, 0)}px`,
                                zIndex: 10 + groupIndex
                              }}
                            >
                              <StackedTodoCards 
                                todos={todoGroup}
                                onTodoClick={handleTodoClick}
                              />
                            </div>
                          );
                        });
                      })()}

                      {/* Background grid lines */}
                      {Array.from({ length: 17 }, (_, hourIndex) => (
                        <div 
                          key={hourIndex} 
                          className="absolute w-full border-t border-gray-100 pointer-events-none"
                          style={{ 
                            top: `${hourIndex * 80}px`,
                            height: '64px'
                          }}
                        />
                      ))}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        </motion.main>

        {/* Todo Modal */}
        <TodoModal 
          isOpen={isModalOpen}
          onClose={() => setIsModalOpen(false)}
          onTodoAdded={handleTodoAdded}
        />

        {/* Todo Details Modal */}
        <TodoDetailsModal
          isOpen={isDetailsModalOpen}
          onClose={() => setIsDetailsModalOpen(false)}
          todo={selectedTodo}
        />
      </div>
    </ProtectedRoute>
  );
}
